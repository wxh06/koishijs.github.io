(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{409:function(v,_,e){"use strict";e.r(_);var t=e(25),a=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[v._v("#")]),v._v(" 生命周期")]),v._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[v._v("注意")]),v._v(" "),e("p",[v._v("这里是"),e("strong",[v._v("正在施工")]),v._v("的 koishi v2 的文档。要查看 v1 版本的文档，请前往"),e("a",{attrs:{href:"https://koishijs.github.io/v1/",target:"_blank",rel:"noopener noreferrer"}},[e("strong",[v._v("这里")]),e("OutboundLink")],1),v._v("。")])]),v._v(" "),e("p",[v._v("如果你已经读完了前面介绍的全部内容，那么本章将会是对上述内容的一个很好的梳理。在这里，你能够深入了解一个 Koishi App 的运作原理。让我们开始吧。")]),v._v(" "),e("h2",{attrs:{id:"总览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总览"}},[v._v("#")]),v._v(" 总览")]),v._v(" "),e("p",[v._v("首先让我们对 App 的生命周期有一个总体的认识：它分为"),e("strong",[v._v("创建阶段")]),v._v("、"),e("strong",[v._v("连接阶段")]),v._v("和"),e("strong",[v._v("运行阶段")]),v._v("。如果考虑销毁过程，还将有两个阶段分别对应连接阶段和创建阶段，用于取消连接和销毁应用。")]),v._v(" "),e("h3",{attrs:{id:"创建阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#创建阶段"}},[v._v("#")]),v._v(" 创建阶段")]),v._v(" "),e("p",[v._v("当执行 "),e("code",[v._v("new App()")]),v._v(" 时，App 的实例创建出来，同时如果配置了相应的字段，"),e("code",[v._v("Database")]),v._v(", "),e("code",[v._v("Sender")]),v._v(", "),e("code",[v._v("Server")]),v._v(" 的实例也会被创建并绑定到 App 上，但它们都尚未连接到服务器。在此之后，便是上下文的构造和插件的安装，因此插件能接触到的 App 实例是这个阶段的。在这个阶段中，如果传入的某些参数有误，将会直接抛出错误，从而终止程序。")]),v._v(" "),e("h3",{attrs:{id:"连接阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#连接阶段"}},[v._v("#")]),v._v(" 连接阶段")]),v._v(" "),e("p",[v._v("当执行 "),e("code",[v._v("app.start()")]),v._v(" 或者 "),e("code",[v._v("startAll()")]),v._v(" 时，App 首先会触发 "),e("code",[v._v("before-connect")]),v._v(" 事件。接着，App 将尝试连接到所有服务器（包括数据库服务器和 CQHTTP 服务器），如果全部连接成功将会触发 "),e("code",[v._v("connected")]),v._v(" 事件。在这个阶段中，如果出现错误，将会抛出一个异步错误，同时 App 不会运行。")]),v._v(" "),e("h3",{attrs:{id:"运行阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#运行阶段"}},[v._v("#")]),v._v(" 运行阶段")]),v._v(" "),e("p",[v._v("当连接成功后，所有 API 都将可以正常调用。在这个阶段中，如果出现错误，将会触发 "),e("code",[v._v("error")]),v._v(" 事件（部分情况也可能导致 unhandledRejection，这取决于插件的写法，例如如果在同步函数内调用异步方法出错就是无法捕捉的）。")]),v._v(" "),e("h3",{attrs:{id:"生命周期图示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生命周期图示"}},[v._v("#")]),v._v(" 生命周期图示")]),v._v(" "),e("p",[v._v("下图大体展示了一个 App 实例的生命周期。你不需要立即弄明白所有的东西，不过随着你的不断学习和使用，它的参考价值会越来越高。图中紫色部分对应创建阶段，玫红色部分对应连接阶段，绿色部分对应运行阶段。")]),v._v(" "),e("p",[e("img",{attrs:{src:"/app-lifecycle.png",alt:"app-lifecycle"}})]),v._v(" "),e("h3",{attrs:{id:"ready-事件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ready-事件"}},[v._v("#")]),v._v(" ready 事件")]),v._v(" "),e("p",[v._v("上面的图中提到了 ready 事件，这个事件比较特殊，因此这里具体介绍一下。之前已经介绍过有个配置项叫做 "),e("code",[v._v("selfId")]),v._v("，表示机器人自身的 QQ 号，它是可选的。这是因为即使不提供这个选项，CQHTTP 的机制也能使得 Koishi 在运行时获得机器人的 QQ 号，而且实在不行也可以通过 "),e("code",[v._v("sender.getLoginInfo()")]),v._v(" 方法直接获取登录号信息。")]),v._v(" "),e("p",[v._v("但是，一般地说，如果你要利用 QQ 号本身进行一些操作，connect 事件本身不能确保 "),e("code",[v._v("app.selfId")]),v._v(" 有值。因此，Koishi 设计了 ready 事件来解决这个问题。"),e("strong",[v._v("ready 事件在成功连接到服务器且已经获得 QQ 号时触发")]),v._v("。这其中包含三种情况：")]),v._v(" "),e("ul",[e("li",[v._v("如果已经配置了 "),e("code",[v._v("selfId")]),v._v(" 字段，那么此事件在 connect 事件后立即触发")]),v._v(" "),e("li",[v._v("如果在运行时显示调用了 "),e("code",[v._v("getSelfIds()")]),v._v(" 方法，则完成 QQ 号获取后触发")]),v._v(" "),e("li",[v._v("其他情况下，当收到含有 "),e("code",[v._v("selfId")]),v._v(" 字段的元信息时，在元信息触发其他事件之前触发")])]),v._v(" "),e("p",[v._v("无论是哪一种情况，当发生此事件时都可以确保 App 实例已经正常运行且可以通过 "),e("code",[v._v("app.selfId")]),v._v(" 获得机器人的 QQ 号。")]),v._v(" "),e("h3",{attrs:{id:"监听器、中间件和指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#监听器、中间件和指令"}},[v._v("#")]),v._v(" 监听器、中间件和指令")]),v._v(" "),e("p",[v._v("我们已经熟悉了 Koishi 的一些基本概念，比如监听器（Receiver）、中间件（Middleware）和指令（Command），那么他们的关系是什么呢？上面的生命周期图也同样告诉了我们答案："),e("strong",[v._v("中间件由内置监听器管理，而指令由内置中间件管理")]),v._v("。没错，当 message 事件被发送到各个上下文的监听器上时，绑定在 App 上的内置监听器将会将这个事件逐一交由中间件进行处理。全部处理完成后会触发一个 after-middleware 事件。")]),v._v(" "),e("p",[v._v("因为我们通常不需要直接监听 message 事件（使用中间件往往是更好的实现），after-middleware 事件的触发通常意味着你对一条消息的处理已经完成。我们的测试工具 koishi-test-utils 就是基于这种逻辑设计了它的 "),e("RouterLink",{attrs:{to:"/guide/unit-tests.html#使用会话"}},[v._v("Session API")]),v._v("。")],1),v._v(" "),e("h2",{attrs:{id:"消息处理机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#消息处理机制"}},[v._v("#")]),v._v(" 消息处理机制")]),v._v(" "),e("p",[v._v("在本节中，我们将完整地回顾整个 Koishi 内部的消息处理机制，从监听器到中间件再到指令，这对理解元信息对象上的各种属性操作有着很大的作用。下面以一个群内指令调用为例，依次介绍其处理流程。这将有助于你理解一个 Meta 对象是如何生成的。")]),v._v(" "),e("h3",{attrs:{id:"server-部分"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#server-部分"}},[v._v("#")]),v._v(" Server 部分")]),v._v(" "),e("ol",[e("li",[v._v("服务器接收到一个事件推送")]),v._v(" "),e("li",[v._v("对 secret 进行比对，如果错误则返回 403")]),v._v(" "),e("li",[v._v("将事件数据转化为 camelCase，得到 Meta 对象")]),v._v(" "),e("li",[v._v("检测 selfId 字段：\n"),e("ul",[e("li",[v._v("如果缺少则自动添加")]),v._v(" "),e("li",[v._v("如果发现与绑定的 selfId 不一致则返回 403")]),v._v(" "),e("li",[v._v("如果是刚刚获取到的则更新 appMap，触发 ready 事件")])])]),v._v(" "),e("li",[v._v("将 CQHTTP 3.x 的格式转化成 4.x，转化数组格式的 message")]),v._v(" "),e("li",[v._v("解析元数据中的字段，生成 "),e("code",[v._v("$ctxType")]),v._v(", "),e("code",[v._v("$ctxId")])]),v._v(" "),e("li",[v._v("根据元数据中的字段生成可能的快捷操作函数，如 "),e("code",[v._v("$send")]),v._v(", "),e("code",[v._v("$delete")]),v._v(" 等")]),v._v(" "),e("li",[v._v("逐一在相关上下文触发 message/normal, message 事件（下接"),e("a",{attrs:{href:"#%E5%86%85%E7%BD%AE%E7%9B%91%E5%90%AC%E5%99%A8"}},[e("strong",[v._v("内置监听器")])]),v._v("）")])]),v._v(" "),e("h3",{attrs:{id:"内置监听器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内置监听器"}},[v._v("#")]),v._v(" 内置监听器")]),v._v(" "),e("ol",[e("li",[v._v("message 事件触发，进入中间件处理流程")]),v._v(" "),e("li",[v._v("根据上下文从中间件池中筛选出要执行的中间件序列")]),v._v(" "),e("li",[v._v("逐一执行中间件：\n"),e("ul",[e("li",[v._v("内置中间件是理论上第一个注册的中间件（下接"),e("a",{attrs:{href:"#%E5%86%85%E7%BD%AE%E4%B8%AD%E9%97%B4%E4%BB%B6"}},[e("strong",[v._v("内置中间件")])]),v._v("）")]),v._v(" "),e("li",[v._v("通过 "),e("code",[v._v("ctx.prependMiddleware()")]),v._v(" 注册的中间件会插在队列的更前面")]),v._v(" "),e("li",[v._v("临时中间件会直接插在当前序列的尾端，并不会影响中间件池本身")]),v._v(" "),e("li",[v._v("如果执行中遇到错误会触发 error/middleware 事件并停止继续执行")])])]),v._v(" "),e("li",[v._v("触发 after-middleware 事件")]),v._v(" "),e("li",[v._v("更新当前用户和群的缓冲数据（参见"),e("RouterLink",{attrs:{to:"/guide/authorization.html#按需加载与更新数据"}},[e("strong",[v._v("按需加载与更新数据")])]),v._v("）")],1)]),v._v(" "),e("h3",{attrs:{id:"内置中间件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内置中间件"}},[v._v("#")]),v._v(" 内置中间件")]),v._v(" "),e("ol",[e("li",[v._v("将 message 繁体转简体，去前后空格")]),v._v(" "),e("li",[v._v("从前缀中匹配 at 机器人，nickname 或 commandPrefix")]),v._v(" "),e("li",[v._v("将 message 中剩下的部分 trim 并转简体，存入 "),e("code",[v._v("meta.$parsed")]),v._v(" 对象")]),v._v(" "),e("li",[v._v("尝试将 "),e("code",[v._v("meta.$parsed.message")]),v._v(" 解析成指令调用")]),v._v(" "),e("li",[v._v("如果 3 不成功：继续尝试解析成快捷方式调用")]),v._v(" "),e("li",[v._v("如果数据库存在：\n"),e("ul",[e("li",[v._v("触发 before-group 事件")]),v._v(" "),e("li",[v._v("获取群数据并存储于 "),e("code",[v._v("meta.$group")])]),v._v(" "),e("li",[v._v("根据 flags, assignee 等字段判断是否应该处理该信息，如果不应该则直接返回")]),v._v(" "),e("li",[v._v("触发 attach-group 事件（用户可以在其中同步地更新群数据）")]),v._v(" "),e("li",[v._v("触发 before-user 事件")]),v._v(" "),e("li",[v._v("获取用户数据并存储于 "),e("code",[v._v("meta.$user")])]),v._v(" "),e("li",[v._v("根据 flags 等字段判断是否应该处理该信息，如果不应该则直接返回")]),v._v(" "),e("li",[v._v("触发 attach-user 事件（用户可以在其中同步地更新群和用户数据）")])])]),v._v(" "),e("li",[v._v("如果解析出指令：执行该指令（下接"),e("a",{attrs:{href:"#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"}},[e("strong",[v._v("指令执行流程")])]),v._v("）")]),v._v(" "),e("li",[v._v("尝试解析出候选指令，如果成功则显示候选项")])]),v._v(" "),e("h3",{attrs:{id:"指令执行流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#指令执行流程"}},[v._v("#")]),v._v(" 指令执行流程")]),v._v(" "),e("ol",[e("li",[v._v("触发 before-command 事件")]),v._v(" "),e("li",[v._v("如果是 -h, --help 则直接显示帮助信息")]),v._v(" "),e("li",[v._v("根据配置检查参数和选项是否合法")]),v._v(" "),e("li",[v._v("根据配置检查用户权限和调用记录")]),v._v(" "),e("li",[v._v("触发 command 事件")]),v._v(" "),e("li",[v._v("调用 action 回调函数")]),v._v(" "),e("li",[v._v("如果上述过程没有调用 next 则触发 after-command 事件")])])])}),[],!1,null,null,null);_.default=a.exports}}]);